local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

local Window = Rayfield:CreateWindow({
   Name = "Kyros Hub | UNIVERSAL SCRIPT",
   Icon = 109550982358013,
   LoadingTitle = "Loading...",
   LoadingSubtitle = "by Krafty Cheese",
   ShowText = "Kyros",
   Theme = "AmberGlow",

   ToggleUIKeybind = "K",

   DisableRayfieldPrompts = false,
   DisableBuildWarnings = false,

   ConfigurationSaving = {
      Enabled = true,
      FolderName = false, -- Create a custom folder for your hub/game
      FileName = "Kyros"
   },

   KeySystem = true, -- Set this to true to use our key system
   KeySettings = {
      Title = "Key System",
      Subtitle = "Key System",
      Note = "No method of obtaining the key is provided", -- Use this to tell the user how to get a key
      FileName = "Key", -- It is recommended to use something unique as other scripts using Rayfield may overwrite your key file
      SaveKey = true, -- The user's key will be saved, but if you change the key, they will be unable to use your script
      GrabKeyFromSite = false, -- If this is true, set Key below to the RAW site you would like Rayfield to get the key from
      Key = {"1234"} -- List of keys that will be accepted by the system, can be RAW file links (pastebin, github etc) or simple strings ("hello","key22")
   }
})

-- | TABS | --

-- Player Tab --
local PlayerTab = Window:CreateTab("Player", 133594514645403)

-- PVP Tab --
local PVPTab = Window:CreateTab("PVP", 122666731572360)

-- Troll Tab --
local TrollTab = Window:CreateTab("Troll", 89512846711639)

-- | Player Tab | --

local Section = PlayerTab:CreateSection("Stats")

-- Walkspeed --
local Players = game:GetService("Players")
local player = Players.LocalPlayer

local Input = PlayerTab:CreateInput({
    Name = "WalkSpeed",
    CurrentValue = "16",
    PlaceholderText = "Enter number...",
    RemoveTextAfterFocusLost = false,
    Flag = "InputWalkSpeed",
    Callback = function(Text)
        local speed = tonumber(Text)
        if speed then
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.WalkSpeed = speed
            end
        else
            warn("Invalid input: not a number")
        end
    end,
})

-- Jump Power --
local Players = game:GetService("Players")
local player = Players.LocalPlayer

local Input = PlayerTab:CreateInput({
    Name = "JumpPower",
    CurrentValue = "50",
    PlaceholderText = "Enter number...",
    RemoveTextAfterFocusLost = false,
    Flag = "InputJumpPower",
    Callback = function(Text)
        local jumpPower = tonumber(Text)
        if jumpPower then
            local character = player.Character or player.CharacterAdded:Wait()
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid then
                humanoid.JumpPower = jumpPower
            end
        else
            warn("Invalid input: not a number")
        end
    end,
})


local Divider = PlayerTab:CreateDivider()

local Section = PlayerTab:CreateSection("Body")

-- Fly Script --
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local flying = false
local flyConnection

local Toggle = PlayerTab:CreateToggle({
    Name = "Fly Toggle",
    CurrentValue = false,
    Flag = "FlyToggle",
    Callback = function(Value)
        flying = Value

        local character = player.Character or player.CharacterAdded:Wait()
        local root = character:WaitForChild("HumanoidRootPart")
        local humanoid = character:WaitForChild("Humanoid")

        if flying then
            humanoid.PlatformStand = true
            local speed = 50
            local rotationSmoothness = 0.2 -- lower = slower turning, higher = snappier
            local velocitySmoothness = 0.3 -- smoothing for velocity changes
            local currentVelocity = Vector3.zero

            flyConnection = RunService.RenderStepped:Connect(function()
                local moveDirection = Vector3.zero

                if UserInputService:IsKeyDown(Enum.KeyCode.W) then
                    moveDirection += workspace.CurrentCamera.CFrame.LookVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.S) then
                    moveDirection -= workspace.CurrentCamera.CFrame.LookVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.A) then
                    moveDirection -= workspace.CurrentCamera.CFrame.RightVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.D) then
                    moveDirection += workspace.CurrentCamera.CFrame.RightVector
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
                    moveDirection += Vector3.new(0,1,0)
                end
                if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
                    moveDirection -= Vector3.new(0,1,0)
                end

                if moveDirection.Magnitude > 0 then
                    local dir = moveDirection.Unit

                    -- Smooth velocity
                    local targetVelocity = dir * speed
                    currentVelocity = currentVelocity:Lerp(targetVelocity, velocitySmoothness)
                    root.Velocity = currentVelocity

                    -- Smooth rotation toward direction
                    local targetCFrame = CFrame.new(root.Position, root.Position + dir)
                    root.CFrame = root.CFrame:Lerp(targetCFrame, rotationSmoothness)
                else
                    -- Smoothly slow down to stop
                    currentVelocity = currentVelocity:Lerp(Vector3.zero, velocitySmoothness)
                    root.Velocity = currentVelocity
                end
            end)

        else
            if flyConnection then
                flyConnection:Disconnect()
                flyConnection = nil
            end
            humanoid.PlatformStand = false
            root.Velocity = Vector3.zero
        end
    end,
})

local Divider = PlayerTab:CreateDivider()

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local Input = PlayerTab:CreateInput({
    Name = "Teleport to Player",
    CurrentValue = "",
    PlaceholderText = "Enter player name or display name",
    RemoveTextAfterFocusLost = false,
    Flag = "Input1",
    Callback = function(Text)
        if Text == "" then return end

        local TargetPlayer
        Text = Text:lower()

        -- Search players by username or display name
        for _, player in pairs(Players:GetPlayers()) do
            if string.find(player.Name:lower(), Text) or string.find(player.DisplayName:lower(), Text) then
                TargetPlayer = player
                break
            end
        end

        if TargetPlayer then
            -- Wait for character to exist
            local character = TargetPlayer.Character or TargetPlayer.CharacterAdded:Wait()
            local hrp = character:WaitForChild("HumanoidRootPart", 5) -- wait max 5 seconds

            if hrp then
                -- Teleport local player
                LocalPlayer.Character.HumanoidRootPart.CFrame = hrp.CFrame
                print("Teleported to "..TargetPlayer.Name.." ("..TargetPlayer.DisplayName..")")
            else
                warn("Target's HumanoidRootPart not found!")
            end
        else
            warn("Player not found!")
        end
    end,
})

local Divider = PlayerTab:CreateDivider()

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

local ClickTPEnabled = false -- toggle state

-- Function to teleport player
local function TeleportToClick()
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end
    local HRP = LocalPlayer.Character.HumanoidRootPart
    if Mouse.Hit then
        HRP.CFrame = CFrame.new(Mouse.Hit.p + Vector3.new(0, 3, 0)) -- +3 Y so you don’t get stuck in the ground
    end
end

-- Listen for clicks when enabled
Mouse.Button1Down:Connect(function()
    if ClickTPEnabled then
        TeleportToClick()
    end
end)

-- Toggle system
local Toggle = PlayerTab:CreateToggle({
   Name = "Click Teleport",
   CurrentValue = false,
   Flag = "ClickTP_Toggle", 
   Callback = function(Value)
      ClickTPEnabled = Value
   end,
})

-- Keybind system (default F)
local Keybind = PlayerTab:CreateKeybind({
   Name = "Teleport Keybind",
   CurrentKeybind = "F",
   HoldToInteract = false,
   Flag = "ClickTP_Keybind",
   Callback = function(KeyDown)
      if KeyDown and ClickTPEnabled then
          TeleportToClick()
      end
   end,
})

local Divider = PlayerTab:CreateDivider()

local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local jumpConnection -- to store the connection so we can disconnect it

local Toggle = PlayerTab:CreateToggle({
    Name = "Infinite Jump",
    CurrentValue = false,
    Flag = "ToggleAutoJump",
    Callback = function(Value)
        if Value then
            -- Connect the jump event when toggle is ON
            jumpConnection = UserInputService.JumpRequest:Connect(function()
                local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    humanoid:ChangeState("Jumping")
                end
            end)
            print("Auto Jump Enabled")
        else
            -- Disconnect the jump event when toggle is OFF
            if jumpConnection then
                jumpConnection:Disconnect()
                jumpConnection = nil
            end
            print("Auto Jump Disabled")
        end
    end,
})

local Divider = PlayerTab:CreateDivider()

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local Clipon = false
local SteppedConnection

local Toggle = PlayerTab:CreateToggle({
    Name = "No-Clip",
    CurrentValue = false,
    Flag = "Toggle1", -- Make sure this is unique if you have other toggles
    Callback = function(Value)
        Clipon = Value
        if Clipon then
            SteppedConnection = RunService.Stepped:Connect(function()
                if LocalPlayer.Character then
                    for _, part in pairs(LocalPlayer.Character:GetChildren()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
            end)
        else
            if SteppedConnection then
                SteppedConnection:Disconnect()
            end
        end
    end,
})

-- | PVP Tab | --

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Highlights = {}
local ESPColor = Color3.fromRGB(255, 0, 0)

-- Create Section for ESP
local ESPSection = PVPTab:CreateSection("ESP")

-- Function to apply highlight
local function ApplyHighlight(player)
    if player == LocalPlayer then return end
    if LocalPlayer.Team ~= nil and player.Team == LocalPlayer.Team then return end -- ✅ Team check
    if not player.Character or Highlights[player] then return end

    local highlight = Instance.new("Highlight")
    highlight.Name = "ESPHighlight"
    highlight.FillColor = ESPColor
    highlight.OutlineColor = Color3.new(0, 0, 0)
    highlight.Adornee = player.Character
    highlight.Parent = player.Character

    Highlights[player] = highlight

    -- Remove highlight when character dies
    local humanoid = player.Character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        humanoid.Died:Connect(function()
            if Highlights[player] then
                Highlights[player]:Destroy()
                Highlights[player] = nil
            end
        end)
    end
end

-- Function to remove highlight
local function RemoveHighlight(player)
    if Highlights[player] then
        Highlights[player]:Destroy()
        Highlights[player] = nil
    end
end

-- ESP Toggle
local ESPToggle = PVPTab:CreateToggle({
    Name = "ESP Highlight",
    CurrentValue = false,
    Flag = "ESPHighlightToggle",
    Callback = function(Value)
        if Value then
            -- Apply ESP to all current players
            for _, player in pairs(Players:GetPlayers()) do
                if player.Character then
                    ApplyHighlight(player)
                end
            end

            -- Handle new players
            Players.PlayerAdded:Connect(function(player)
                player.CharacterAdded:Connect(function(char)
                    task.wait(1) -- wait for character to load fully
                    if ESPToggle.CurrentValue then
                        ApplyHighlight(player)
                    end
                end)
            end)

            -- Handle respawns for existing players
            for _, player in pairs(Players:GetPlayers()) do
                player.CharacterAdded:Connect(function(char)
                    task.wait(1)
                    if ESPToggle.CurrentValue then
                        ApplyHighlight(player)
                    end
                end)
            end
        else
            -- Turn off all highlights
            for _, highlight in pairs(Highlights) do
                if highlight then
                    highlight:Destroy()
                end
            end
            Highlights = {}
        end
    end,
})

-- ESP Color Picker
local ESPColorPicker = PVPTab:CreateColorPicker({
    Name = "ESP Color",
    Color = ESPColor,
    Flag = "ESPColorPicker",
    Callback = function(Value)
        ESPColor = Value
        for _, highlight in pairs(Highlights) do
            highlight.FillColor = ESPColor
        end
    end,
})

local Divider = PVPTab:CreateDivider()

-- Auto add highlight to new players
Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        if ESPToggle.CurrentValue then
            ApplyHighlight(character)
        end
    end)
end)

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local tracers = {} -- store lines
local connections = {} -- track death/respawn connections

-- Settings
local tracerColor = Color3.fromRGB(255, 0, 0) -- default red
local lineThickness = 2

-- Function to update all tracer colors when picker changes
local function updateTracerColors(newColor)
    tracerColor = newColor
    for _, line in pairs(tracers) do
        line.Color = tracerColor
    end
end

-- Function to create a tracer for a player
local function createTracer(player)
    if player == LocalPlayer then return end
    if tracers[player] then return end

    local line = Drawing.new("Line")
    line.Color = tracerColor
    line.Thickness = lineThickness
    line.Transparency = 1
    line.Visible = true
    tracers[player] = line

    -- Handle character respawn/death
    local function setupCharacter(character)
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.Died:Connect(function()
                if tracers[player] then
                    tracers[player].Visible = false
                end
            end)
        end
    end

    -- Existing character
    if player.Character then
        setupCharacter(player.Character)
    end

    -- Listen for new spawns
    connections[player] = player.CharacterAdded:Connect(setupCharacter)
end

-- Function to remove a tracer completely
local function removeTracer(player)
    if tracers[player] then
        tracers[player]:Remove()
        tracers[player] = nil
    end
    if connections[player] then
        connections[player]:Disconnect()
        connections[player] = nil
    end
end

-- Add tracers for existing players
for _, player in pairs(Players:GetPlayers()) do
    createTracer(player)
end

-- Handle new/removed players
Players.PlayerAdded:Connect(createTracer)
Players.PlayerRemoving:Connect(removeTracer)

-- RenderStepped update function
local function updateTracers()
    for player, line in pairs(tracers) do
        if player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local root = player.Character.HumanoidRootPart
            local screenPos = Camera:WorldToViewportPoint(root.Position)
            line.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2) -- center of screen
            line.To = Vector2.new(screenPos.X, screenPos.Y)
            line.Visible = screenPos.Z > 0
        else
            line.Visible = false
        end
    end
end

-- Rayfield Toggle
local Toggle = PVPTab:CreateToggle({
    Name = "Tracers",
    CurrentValue = false,
    Flag = "TracersToggle",
    Callback = function(Value)
        if Value then
            -- Enable tracers
            RunService:BindToRenderStep("ESPTracers", 500, updateTracers)
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer then
                    createTracer(player)
                end
            end
        else
            -- Disable tracers and remove lines
            RunService:UnbindFromRenderStep("ESPTracers")
            for _, line in pairs(tracers) do
                line:Remove()
            end
            tracers = {}
            for _, conn in pairs(connections) do
                conn:Disconnect()
            end
            connections = {}
        end
    end,
})

-- Rayfield Color Picker
local ColorPicker = PVPTab:CreateColorPicker({
    Name = "Tracer Color",
    Color = Color3.fromRGB(255, 0, 0), -- default red
    Flag = "TracerColorPicker",
    Callback = function(Value)
        updateTracerColors(Value)
    end,
})

local Divider = PVPTab:CreateDivider()

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- Store active connections so we can clean them later
local connections = {}
local outlineColor = Color3.fromRGB(255, 0, 0) -- default red

-- Function to update outline colors dynamically
local function updateOutlineColors(newColor)
    outlineColor = newColor
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            for _, part in pairs(player.Character:GetChildren()) do
                if part:IsA("BasePart") then
                    local box = part:FindFirstChild("ESP_Outline")
                    if box then
                        box.Color3 = outlineColor
                    end
                end
            end
        end
    end
end

local function addOutline(character)
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") then
            local box = Instance.new("SelectionBox")
            box.Name = "ESP_Outline"
            box.Adornee = part
            box.LineThickness = 0.05
            box.Color3 = outlineColor
            box.Parent = part
        end
    end

    -- Remove outlines when player dies
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        local deathConn
        deathConn = humanoid.Died:Connect(function()
            removeOutline(character)
            if deathConn then
                deathConn:Disconnect()
            end
        end)
        connections[character] = deathConn
    end
end

function removeOutline(character)
    for _, part in pairs(character:GetChildren()) do
        if part:IsA("BasePart") then
            local box = part:FindFirstChild("ESP_Outline")
            if box then
                box:Destroy()
            end
        end
    end
    if connections[character] then
        connections[character]:Disconnect()
        connections[character] = nil
    end
end

-- Rayfield Toggle
local Toggle = PVPTab:CreateToggle({
    Name = "ESP Outline",
    CurrentValue = false,
    Flag = "OutlineToggle",
    Callback = function(Value)
        if Value then
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character then
                    addOutline(player.Character)
                end
            end
        else
            for _, player in pairs(Players:GetPlayers()) do
                if player.Character then
                    removeOutline(player.Character)
                end
            end
        end
    end,
})

-- Rayfield Color Picker
local ColorPicker = PVPTab:CreateColorPicker({
    Name = "Outline Color",
    Color = Color3.fromRGB(255, 0, 0), -- default red
    Flag = "OutlineColorPicker",
    Callback = function(Value)
        updateOutlineColors(Value)
    end,
})

-- Apply ESP to new players
Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(char)
        if Toggle.CurrentValue then
            task.wait(0.1)
            addOutline(char)
        end
    end)
end)

local Divider = PVPTab:CreateDivider()

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer
local Toggles = {} -- Stores BillboardGuis per player
local Enabled = false -- Toggle state
local textColor = Color3.fromRGB(255, 0, 0) -- default red

-- Function to update all billboard colors
local function UpdateBillboardColors(newColor)
    textColor = newColor
    for _, billboard in pairs(Toggles) do
        if billboard and billboard:FindFirstChild("NameDistLabel") then
            billboard.NameDistLabel.TextColor3 = textColor
        end
    end
end

-- Function to create BillboardGui with name + distance
local function CreateBillboard(player)
    if player.Character and player.Character:FindFirstChild("Head") then
        -- prevent duplicates
        if player.Character.Head:FindFirstChild("NameDistBillboard") then
            player.Character.Head.NameDistBillboard:Destroy()
        end

        local Billboard = Instance.new("BillboardGui")
        Billboard.Name = "NameDistBillboard"
        Billboard.Adornee = player.Character.Head
        Billboard.Size = UDim2.new(0, 200, 0, 50)
        Billboard.StudsOffset = Vector3.new(0, 2.5, 0)
        Billboard.AlwaysOnTop = true

        local TextLabel = Instance.new("TextLabel")
        TextLabel.Name = "NameDistLabel"
        TextLabel.Size = UDim2.new(1, 0, 1, 0)
        TextLabel.BackgroundTransparency = 1
        TextLabel.TextColor3 = textColor
        TextLabel.TextStrokeTransparency = 0.5
        TextLabel.TextScaled = true
        TextLabel.Font = Enum.Font.SourceSansBold
        TextLabel.Parent = Billboard

        Billboard.Parent = player.Character.Head
        Toggles[player] = Billboard
    end
end

-- Hide / show default Roblox overhead names
local function SetDefaultNameVisible(player, visible)
    if player.Character and player.Character:FindFirstChild("Humanoid") then
        local humanoid = player.Character:FindFirstChild("Humanoid")
        if visible then
            humanoid.NameDisplayDistance = 100 -- default distance
        else
            humanoid.NameDisplayDistance = 0
        end
    end
end

-- Update distance text
local function UpdateText()
    if not Enabled then return end
    if not LocalPlayer.Character or not LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return end

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local billboard = Toggles[player]
            if billboard and billboard:FindFirstChild("NameDistLabel") then
                local distance = (LocalPlayer.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
                billboard.NameDistLabel.Text = string.format("%s\n[%.0f]", player.DisplayName, distance)
            end
        end
    end
end

-- Handle respawn properly
local function HookPlayer(player)
    player.CharacterAdded:Connect(function(char)
        if Enabled then
            task.wait(1) -- wait for head to load
            CreateBillboard(player)
            SetDefaultNameVisible(player, false)
        end
    end)

    player.CharacterRemoving:Connect(function()
        if Toggles[player] then
            Toggles[player]:Destroy()
            Toggles[player] = nil
        end
    end)
end

-- Existing players
for _, player in pairs(Players:GetPlayers()) do
    if player ~= LocalPlayer then
        HookPlayer(player)
    end
end

-- New players
Players.PlayerAdded:Connect(function(player)
    if player ~= LocalPlayer then
        HookPlayer(player)
    end
end)

-- Cleanup when players leave
Players.PlayerRemoving:Connect(function(player)
    if Toggles[player] then
        Toggles[player]:Destroy()
        Toggles[player] = nil
    end
end)

-- Connect update loop
RunService.RenderStepped:Connect(UpdateText)

-- Rayfield Toggle
local Toggle = PVPTab:CreateToggle({
    Name = "Player Name + Distance",
    CurrentValue = false,
    Flag = "NameDistToggle",
    Callback = function(Value)
        Enabled = Value
        if Value then
            -- Enable: create Billboards for all players + hide default names
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character then
                    CreateBillboard(player)
                    SetDefaultNameVisible(player, false)
                end
            end
        else
            -- Disable: remove all Billboards + restore default names
            for _, billboard in pairs(Toggles) do
                if billboard then billboard:Destroy() end
            end
            Toggles = {}
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer then
                    SetDefaultNameVisible(player, true)
                end
            end
        end
    end,
})

-- Rayfield Color Picker
local ColorPicker = PVPTab:CreateColorPicker({
    Name = "Name + Distance Color",
    Color = Color3.fromRGB(255, 0, 0), -- default white
    Flag = "NameDistColorPicker",
    Callback = function(Value)
        UpdateBillboardColors(Value)
    end,
})

local Divider = PVPTab:CreateDivider()

local ESPSection = PVPTab:CreateSection("Aimbot")

local Paragraph = PVPTab:CreateParagraph({Title = "How to use Aimbot", Content = "For the Aimbot once you toggle it on click Q to change players, Click E to toggle on or off!"})

-- AIM AT OTHER PLAYERS WITH RAYFIELD KEYBIND + STATUS GUI
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local currentTargetIndex = 1
local aimbotEnabled = false  -- Controlled by Rayfield toggle
local aimingActive = true    -- Controlled by keybind
local aimSmoothness = 0.15 -- Lower = slower, higher = snappier
local maxAimDistance = 100 -- ✅ Max distance in studs

-- ✅ GUI Setup
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "AimbotStatusGui"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = game:GetService("CoreGui")

local StatusLabel = Instance.new("TextLabel")
StatusLabel.Size = UDim2.new(0, 120, 0, 30)
StatusLabel.Position = UDim2.new(1, -130, 0.45, 0) -- right-hand side
StatusLabel.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
StatusLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
StatusLabel.Font = Enum.Font.GothamBold
StatusLabel.TextSize = 16
StatusLabel.Visible = false
StatusLabel.Text = "Aimbot: OFF"
StatusLabel.Parent = ScreenGui

local function UpdateStatus()
    if aimbotEnabled then
        StatusLabel.Visible = true
        if aimingActive then
            StatusLabel.Text = "Aimbot: ON"
            StatusLabel.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
        else
            StatusLabel.Text = "Aimbot: OFF"
            StatusLabel.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
        end
    else
        StatusLabel.Visible = false
    end
end

-- Toggle (Rayfield)
local AimToggle = PVPTab:CreateToggle({
    Name = "Player Aim Toggle",
    CurrentValue = false,
    Flag = "PlayerAimToggle",
    Callback = function(Value)
        aimbotEnabled = Value
        UpdateStatus()
    end,
})

-- Keybind to pause/resume aiming
local AimKeybind = PVPTab:CreateKeybind({
    Name = "Pause/Resume Aim",
    CurrentKeybind = "E",
    HoldToInteract = false,
    Flag = "PauseAimKeybind",
    Callback = function()
        if aimbotEnabled then
            aimingActive = not aimingActive
            UpdateStatus()
        end
    end,
})

-- Get list of valid enemy players (teams + wall check + distance check)
local function GetOtherPlayers()
    local list = {}
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer 
            and player.Character 
            and player.Character:FindFirstChild("Head") 
        then
            -- ✅ Team check
            if LocalPlayer.Team ~= nil and player.Team == LocalPlayer.Team then
                continue
            end

            local head = player.Character.Head
            local origin = Camera.CFrame.Position
            local distance = (head.Position - origin).Magnitude

            -- ✅ Distance check
            if distance > maxAimDistance then
                continue
            end

            -- ✅ Wall check
            local direction = (head.Position - origin)
            local raycastParams = RaycastParams.new()
            raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
            raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}

            local result = workspace:Raycast(origin, direction, raycastParams)

            if result and result.Instance:IsDescendantOf(player.Character) then
                table.insert(list, player)
            end
        end
    end
    return list
end

-- Switch target with Q
UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == Enum.KeyCode.Q then
        local targets = GetOtherPlayers()
        if #targets > 0 then
            currentTargetIndex = currentTargetIndex + 1
            if currentTargetIndex > #targets then
                currentTargetIndex = 1
            end
        end
    end
end)

-- Smooth aiming loop
RunService.RenderStepped:Connect(function()
    if aimbotEnabled and aimingActive then
        local targets = GetOtherPlayers()
        if #targets > 0 then
            local targetPlayer = targets[currentTargetIndex]
            if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("Head") then
                local headPos = targetPlayer.Character.Head.Position
                local direction = (headPos - Camera.CFrame.Position)
                local newCFrame = CFrame.new(
                    Camera.CFrame.Position, 
                    Camera.CFrame.Position + direction:Lerp(direction, aimSmoothness)
                )
                Camera.CFrame = newCFrame
            end
        end
    end
end)

local Divider = PVPTab:CreateDivider()

-- SOFT LOCK AIM ASSIST WITH CURSOR PLAY + TEAM/WALL CHECK + GUI STATUS
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local aimbotEnabled = false  -- Controlled by Rayfield toggle
local aimingActive = true    -- Controlled by keybind
local aimSmoothness = 0.15 -- Lower = slower, higher = snappier
local maxScreenDistance = 200 -- Cursor "play" range

-- ✅ Create GUI
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "SoftLockStatusGui"
ScreenGui.ResetOnSpawn = false
ScreenGui.Parent = game:GetService("CoreGui")

local StatusLabel = Instance.new("TextLabel")
StatusLabel.Size = UDim2.new(0, 120, 0, 30)
StatusLabel.Position = UDim2.new(1, -130, 0.4, 0) -- right side
StatusLabel.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
StatusLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
StatusLabel.Font = Enum.Font.GothamBold
StatusLabel.TextSize = 16
StatusLabel.Visible = false -- hidden until toggle ON
StatusLabel.Text = "Soft Lock: OFF"
StatusLabel.Parent = ScreenGui

local function UpdateStatus()
    if aimbotEnabled then
        StatusLabel.Visible = true
        if aimingActive then
            StatusLabel.Text = "Soft Lock: ON"
            StatusLabel.BackgroundColor3 = Color3.fromRGB(0, 170, 0)
        else
            StatusLabel.Text = "Soft Lock: OFF"
            StatusLabel.BackgroundColor3 = Color3.fromRGB(170, 0, 0)
        end
    else
        StatusLabel.Visible = false
    end
end

-- Toggle (Rayfield)
local AimToggle = PVPTab:CreateToggle({
    Name = "Player Soft Lock Toggle",
    CurrentValue = false,
    Flag = "PlayerSoftLockToggle",
    Callback = function(Value)
        aimbotEnabled = Value
        UpdateStatus()
    end,
})

-- Keybind to pause/resume aiming
local AimKeybind = PVPTab:CreateKeybind({
    Name = "Pause/Resume Soft Lock",
    CurrentKeybind = "E",
    HoldToInteract = false,
    Flag = "PauseSoftLockKeybind",
    Callback = function()
        if aimbotEnabled then
            aimingActive = not aimingActive
            UpdateStatus()
        end
    end,
})

-- Find best target near mouse (team check + wall check + cursor play)
local function GetClosestToCursor()
    local mouseLocation = UserInputService:GetMouseLocation()
    local closestPlayer = nil
    local closestDist = maxScreenDistance

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer 
            and player.Character 
            and player.Character:FindFirstChild("Head") 
        then
            -- ✅ Team check
            if LocalPlayer.Team ~= nil and player.Team == LocalPlayer.Team then
                continue
            end

            -- ✅ Wall check
            local head = player.Character.Head
            local origin = Camera.CFrame.Position
            local direction = (head.Position - origin)

            local raycastParams = RaycastParams.new()
            raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
            raycastParams.FilterDescendantsInstances = {LocalPlayer.Character}
            local result = workspace:Raycast(origin, direction, raycastParams)

            if result and result.Instance:IsDescendantOf(player.Character) then
                -- ✅ Cursor play (soft lock bubble around mouse)
                local screenPos, onScreen = Camera:WorldToViewportPoint(head.Position)
                if onScreen then
                    local screenDist = (Vector2.new(screenPos.X, screenPos.Y) - mouseLocation).Magnitude
                    if screenDist < closestDist then
                        closestDist = screenDist
                        closestPlayer = player
                    end
                end
            end
        end
    end

    return closestPlayer
end

-- Soft lock loop
RunService.RenderStepped:Connect(function()
    if aimbotEnabled and aimingActive then
        local targetPlayer = GetClosestToCursor()
        if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("Head") then
            local headPos = targetPlayer.Character.Head.Position
            local direction = (headPos - Camera.CFrame.Position)
            local newCFrame = CFrame.new(
                Camera.CFrame.Position, 
                Camera.CFrame.Position + direction:Lerp(direction, aimSmoothness)
            )
            Camera.CFrame = newCFrame
        end
    end
end)

-- | Troll Tab | --

local Button = TrollTab:CreateButton({
   Name = "R6 Jerk Off",
   Callback = function()
   loadstring(game:HttpGet("https://pastefy.app/wa3v2Vgm/raw"))()
   end,
})

local Button = TrollTab:CreateButton({
   Name = "R15 Jerk Off",
   Callback = function()
   loadstring(game:HttpGet("https://pastefy.app/YZoglOyJ/raw"))()
   end,
})

local Divider = TrollTab:CreateDivider()

local Button = TrollTab:CreateButton({
   Name = "Fling Gui",
   Callback = function()
   loadstring(game:HttpGet("https://raw.githubusercontent.com/LiarRise/FLN-X/refs/heads/main/README.md"))()
   end,
})
